## 프로미스(promise)

### 프로미스(promise)의 배경
- 프로미스를 한 문장으로 표현하면 "비동기 통신 콜백 지옥의 확실한 해결책"
- XMLHttpRequest 객체로 비동기 통신을 하면 콜백 함수를 사용해 응답 결과에 대한 처리를 해야한다.

* XMLHttpRequest 객체로 받은 응답을 기초로 다시 비동기 요청을 하거나 비동기 처리 해야 할때,
복잡한 서비스를 구현하는 경우 2~3단계 이상은 기본으로 비동기 요청을 하게 되고, 각각의 돌아오는 응답을 처리하는 콜백 함수를 붙이게 된다.
개발된 코드는 초기 개발 후 이런 저런 변화와 업데이트를 거치게 되는데, 이렇게 2~3단계로 비동기 요청이 중첩되면, 비동기 호출의 콜백 함수의 어느 부분을 수정해야 하는지 판단하는게 쉽지 않아 진다.
> 이렇게 다단으로 중첩된 비동기 호출과 콜백 함수의 혼돈을 해결하기위해 나온 기술, 또는 기법이 프로미스.
- 프로미스는 중첩되는 비동기 호출과 응답 처리를 체인 형태로 하나의 긴 연쇄 작업으로 펼쳐준다.
> 프로미스는 인터넷 익스플로러에서는 지원이 되지 않는다. 호환성이 필요한 경우 프로미스 대신 AJAX(HMLHttpRequest)를 사용할 것.

### 프로미스 객체의 상태와 메서드
|        상태         |          설명        |
|--------------------|:--------------------:|
|       대기중(pending)|프로미스 객체의 기본 상태, 비동기 처리 결과가 나오지 않은 상태|
|이행 완료됨(Fullfilled)|비동기 처리가 완료되어 결과를 얻은 상태, resolve()함수를 호출함.|
|      거부됨(Rejected)|비동기 처리는 완료되었지만, 실패한 상태. reject()함수를 호출|

|     메서드    |      설명      |
|-------------|:-------------:|
|  then()메서드 | 비동기 처리가 완료되었을 때 메서드, 메서드 파라메터로 콜백 함수를 등록하며, 콜백 함수 파라메터로 결과 데이터, 또는 메시지를 받아 최종 데이터 처리 작업을 할 수 있다.|
|  catch()메서드| 프로미스가 거부 되었을 때 호출되는 메서드, 메서드 파라메터로 콜백 함수를 등록하며, 거부시에 콜백 함수가 실행된다. 콜백 함수 파라메터로 에러 메시지를 받을 수 있다.|

**대기중 상태**는 비동기 요청이 처리중인 상태로 이행 완료, 또는 거부되기 전에 결과(응답)를 기다리고 있는 상태.
**이행 완료 상태**가 되면 프로미스 인스턴스는 then()메서드의 파라메터로 작성한 콜백 함수를 호출.
**거부 상태**가 되면 catch()메서드의 파라메터로 작성한 콜백 함수를 호출.

#### 프로미스 기본 사용법
```javascript
let myPromise = new Promise((resolve, reject)=>{
  setTimeout(()=>{
    let result = 'promise fulfilled';
    resolve(result); // 비동기 수신 결과를 인자로 넣어 콜백을 호출함.
  }, 1000)
});
myPromise.then((successMessage)=>{
  // resolve 에서 받은 파라메터 정보를 콘솔에 출력.
  console.log(successMessage);
}).catch((failMessage)=>{
  // reject()에러 메시지 출력
  console.log(failMessage)
});
```

1. 프로미스 인스턴스를 생성
- 프로미스 객체를 작성할 때는 파라메터 2개를 가지는 비동기 처리 함수를 작성.
- 첫번째 파라메터에는 이행이 완료되었을때 호출하는 이행 완료 함수 명이고,
- 두번째 파라메터는 호출하는 거부 함수 명.
- 편의상 이행완료는 resolve, 실패 함수명은 reject을 많이 사용.

`setTimeout()`은 가상으로 AJAX원격 호출에 대한 응답을 흉내내기 위해서 사용한 것.
실제로는 비동기 서버에서 원격 요청을 보내 응답을 받는 코드가 들어가게 된다.


- 생성자 파라메터에 정한 함수명을 호출하면, 프로미스 인스턴스에서 메서드 체인으로 then(), catch()중 하나를 호출한다. 
* 이행이 완료되어 resolve()함수를 호출하면 then()메서드의 파라메터에 정의한 콜백 함수가 실행된다. 
* 이행이 거부되어 reject()함수를 호출하면 catch()메서드의 파라메터에 정의한 콜백 함수가 실행된다.
then(), catch()의 콜백 함수는 파라메터를 통해 데이터, 또는 메시지를 전달 할 수 있다.
> 프로미스를 이용해 비동기 통신 한 개를 처리하는 것은 XMLHttpRequest를 이용해 AJAX통신을 하는 방법과 별다른 차이점이나 장점이 없고, 다중 비동기 처리할때 유용하다!

### 다중 프로미스 처리
#### 다중 프로미스 실행의 예
```javascript
function asyncWork(value){
  return new Promise((resolve, reject)=>{
    setTimeout(()=>{
      value -= 20;
      if(value > 50){
        resolve(value);
      }else{
        reject(value)
      }
    },1000)
  })
}
// 프로미스 요청/응답 제안
asyncWork(100).then((value)=>{
  console.log(value);
  return asyncWork(value); 
}).then((value)=>{
  console.log(value);
  return asyncWork(value); 
}).then((value)=>{
  console.log(value);
  return asyncWork(value); 
}).catch(err=>{
  console.log('catch:'+ err)
});


// 80
// 60
// catch:40
```

- asyncWork()함수는 프로미스 인스턴스 반환하므로 함수를 호출하면서 메서드 체인으로 then()을 호출할 수 있다.
- 다중 프로미스의 핵심은 이렇게 체인으로 호출하는 then()메서드의 콜백 함수의 반환(return)값으로 프로미스 인스턴스를 생성하는 함수를 다시 호출한다는 것.
- 반환된 프로미스 인스턴스는 다음 번 then()의 프로미스 인스턴스가 된다.
- then()메서드는 콜백 함수에서 반환하는 asyncWork()프로미스 인스턴스의 비동기 처리가 완료되기전까지 다음 번 then()을 호출하지 않고 대기한다.
**따라서 모든 비동기 처리 작업은 then(콜백함수) 순서대로 하나씩 실행되고, 콜백 함수의 파라메터를 통해 결과 값을 순차적으로 전달.**
- 마지막으로 프로미스 인스턴스가 상태가 거절 상태가 되면 다음번 then()으로 가지 않고 catch()로 바로 빠지면서 거절 메세지를 출력하고 *종료*.

// 클로저란
// 실행시점의 환경 정보를 기억해 실행 종료 후에도 익명함수에 환경 정보의 값을 전달해 줄 수 있다.
// —> 만들어진 시점의 실행 환경을 기억하는 함수.

// 클로저 함수를 호출한 함수가 종료되더라도, 호출한 함수의 환경(변수 등) 클로저 함수가 기억하고 있는것.
// 함수를 예를 들어 설명.
// 클로저는 다음과 같은 방식으로 익명 함수를 반환해 구현을 하므로 구조를 잘 숙제해 둬야한다.


function outerFunc(name){
  let saying = name + '안녕';
  return function(){
    return saying;
  }
}
let clousere1 = outerFunc('라이언');
let clousere2 = outerFunc('콘');

console.log(clousere1());
console.log(clousere2());


// “outerFunc()”는 익명함수를 반환합니다. 
// 반환된 함수는 변수에 저장되고, 익명함수를 실행하면 익명함수가 반환하는 “saying”변수의 값을 콘솔에 표시한다.

// *** 여기서 중요한 점은 "outerFunc()" 함수가 이미 종료되었다는 점. 
// "outerFunc()" 함수가 종료되었기 때문에 함수 로컬 변수인 "saying"도 사라져야함. 
// 하지만 반환된 클로저를 실행하면 “saying”변수의 값이 출력되고, 거기에 더해 넘긴 파라메터 값까지 적용된
// “saying” 변수가 출력된다는점.


// 클로저는 실행함수를 기억하는 특성이 있어서 여러가지 상황에 따른 메시지를 표시하거나
// 위치에 맞는 값을 표시하는 등 반복되는 이벤트 처리를 구현하는데 매우 뛰어난 효율을 보인다.

// 코드를 단순화하고 확장성을 높일 수 있는 장점이 있지만, 구현상의 실수로 반복문 지옥에 빠질수도 있다.

// 반복문으로 클로저를 생성할 경우 흔하게 발생하는 문제로 실행환경의 변수 값이 원하는 값이 아닌 경우이다.
// 루프를 돌면서 각각의 클로저에 맞는 실행환경 변수 값이 적용 될 거라고 예상하지만 실제로는 마지막 값을 참조하는 경우이다.




// > 클로저의 단점

// >> 실행환경을 기억하는 것은 파라메터를 일일이 넘겨야 하는 번거로움을 줄여주고, 데이터의 보안성도 동시에 높이는 장점이 있다.
// 반면, 실행될때마다 각각의 참조데이터를 유지해야 하기 때문에 메모리 사용량이 늘어난다.
// 실행환경에서 유지해야 하는 데이터가 큰 경우 클로저는 생각 보다 많은 메모리를 소모한다.
// 따라서 클로저는 사용후에는 메모리를 해제해 불필요한 메모리 소모를 줄여야한다.

// 클로저 해제는
// clousere1 = null;
// 과 같이 클로저 변수에 널(null)을 대입하면 된다.

// 클로저의 장점

// >> 클로저는 변수를 탐색할 때 실행환경에서만 찾기 때문에 
// 스코프 체인을 따라 올라가 전역변수까지 확인하는 과정이 없어, 
// 스코프 탐색에 시간이 덜 소모되는 등 실행 속도상의 이점도 있다.

// 또한, 비동기 처리 후 결과를 비교하거나 조합하는 경우, 실행 환경의 참조에 필요한 데이터를 가지고 있기 때문에
// 전역변수를 따로 만들어 처리하는 방법보다 훨씬 세련된 처리가 가능.

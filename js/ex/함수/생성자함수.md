## 생성자 함수

### 반복자(iterator), 또는 이터레이터
- 생성자 함수에 앞서 반복자를 먼저 알아야한다.
- 반복되는 연산 작업을 함수를 사용해 구현하는 방식을 이터레이터(반복자)라고 한다.
- 함수 안에 단위 실행 1번을 실행하는 객체 리터럴과 현재 값을 유지하는 변수를 생성해 사용자가 실행단위 별로 개별 실행할 수 있게 만드는 구현방식.
- 
```javascript
function calcSum(start = 1, end = Infinity){
  let current = start;
  let sum = 0;
  let accumulate = {
    next: function(){
      let ret = null;
      if(current <= end){ // 마자막 정수 값을 포함해 합계를 구한다.
        ret = {value: current, done: false}
      } else {
        ret = {value: sum, done: true}
      }
      sun += current;
      current++;
      return ret;
    }
  }
  return accumulate;
}
let calc = calcSum(1, 10);
let result = calc.next();
console.log("처음실행: ");
console.log(result);
while(!result.done){
  result = calc.next();
}
console.log("합계출력: ");
console.log(result);

// 처음실행:
// {value:1, done: false}
// 합계출력
// {value:55, done: true}
```

2개의 정수 파라메터를 받아서 두 정수 사이의 숫자의 누적합을 구하는 이터레이터 함수 구현이다.
calcSum() 함수 안에 사용 변수와 단위 실행을 하는 next()메서드를 내장한 객체 리터럴을 구현한 것.

이터레이터의 의도는 분명해서 로직을 구현하는데 필요한 모든 것을 하나의 함수안에 내장해서 캡슐화를 하고,
단일 메서드인 next()를 호출해 한 개의 반복 실행 단위를 실행하도록 한다.

이터레이터의 의도는 분명해서 로직을 구현하는데 필요한 모든 것을 하나의 함수 안에 내장해서 캡슐화를 하고,
단일 메서드인 next()를 호출해 한 개의 반복 실행 단위를 실행하도록 한다.

살짝 객체 지향 적인 구현 방법이지만, 그냥 단일 함수 안에서 루프를 돌아 결과 값을 반환 받는 것보다 그다지 좋을 게 없다.

참고로 내부 객체 리터럴의 메서드 이름인 "next()"는 다른 이름 이어도 무관하다.
다음에 설명할 생성자 함수에서 next()메서드를 내장된 고정 메서드 이름으로 사용하기 때문에 맞춰서 사용한다는 것.

현재 위치 값을 알고 있고 한번에 반복되는 실행 로직을 1번씩 실행하는 구현 방식을 반복자, 또는 이터레이터라고 하며, 
이렇게 이터레이터로 표현할 수 있는 함수를 이터러블이라고 한다.

예제에서는 누적 합을 구하는 간단한 함수를 이터레이터로 구현했지만, 배열이나 객체를 파라메터로 받아서 각 요소나 속성에 대한 처리를 하는 기능을 구현할 수도 있다.

이런 객체 지향 적인 캡슐화 된 접근이 유용한 경우는 단위 실행을 하는 중간 상태를 유지해야하고, 중간 상태에 따라 다른 분기를 해야하는 경우이다.

다분히 예외적인 경우이고, 이런 경우라면 그냥 객체 리터럴로 다양한 메서드를 내부에 구현해 해결할 수도 있다.
왠지 쉬운 길을 어럽게 돌아가는 이런 객체 지향 적인 접근 방법을 어쨋든 "이터레이터"라고 한다.
##### 이런 구현방법은 거의 사용하지 않는다.




### 생성자 함수

이터레이터는 내부에 순환 반복을 도는데 필요한 현재 상태 값을 유지해야할 필요가 있다.
객체 지향의 관점에서 보면 함수를 캡슐화 하는데 전역 변수에 접근하기 위한 참조를 계속 유지하는 것과 같은 식이 된다.

생성자 함수는 이 현재 상태 값을 유지하지 않을 수 있게 해주는 구현 방법.

이터레이터가 캡슐화라는 구현 방식에 대한 접근이라면 생성자 함수는 캡슐화를 위해 명시적으로 추가된 문법을 제공.
기존 함수 선언자인 "function" 뒤에 "*"를 붙여서 
"function*" 함수를 선언하면 이 함수는 생성자 함수로 선언한 것이고, 
생성자 함수 구현 로직과, 추가의 생성자 함수 키워드를 사용할 수있게 된다.

```javascript
function* calcSum(start = 1, end = Infinity){
  let sum = 0;
  for(let i=start; i<=end; i++){ // 마지막 정수 값을 포함해 합계를 구한다.
    sum += i;
    yield i;
  }
  return sum;
}
let calc = calcSum(1,10);
let result = calc.next();
console.log("처음실행: ");
console.log(result);
while(!result.done){
  result = calc.next()
}
console.log("합계출력: ");
console.log(result);


// 처음실행:
// {value:1, done: false}
// 합계출력
// {value:55, done: true}
```

시작 정수 값부터 끝 정수 값까지 for 문으로 순환을 해서 합을 구하는 로직인데
실제로 실행 해보면 루프를 1번만 실행한 결과가 나옵니다. 거기다 선언되지도 않은 next()함수를 호출하는데
아무렇지도 않게 실행된다.

생성자 함수의 이 객체 지향적인 독특한 접근 방법은 캡슐화 측면에서는 굉장히 간결하고 성공적이지만,
가독성을 심각하게 떨어지는 문제가 있다. 그리고 용도가 예제와 비슷한 경우라만 한정된다.

먼저 순환문 안에 yield, 그리고 next()메서드는 2개의 키워드를 알아야 한다.

yield 현재 도는 루프의 반복문 변수의 현재 값을 상태 값으로 넘긴다.
앞서 이터레이터에서 구현했던 현재 상태를 유지하는 용도인 ret 객체 그대로가 똑같이 반환된다.
반복문 변수는 value 속성으로 반환된다.

next()메서드는 내장 메서드.
이터레이터에서는 객체 리터럴의 메서드 이름을 원하는 대로 바뀌도 되지만 생성자 함수에서는 next()로 고정이다.
기능은 앞서 구현한 이터레이터의 next()메서드와 동일하다.

순환문 반복 중 해당 루프 변수값에 해당하는 실행 1회만 실행하고 현재 상태 객체를 반환한다.

이 ES6 구현 방식은 자바스크립트 입문자에게는 너무 이상한 사용 방식일 뿐만 아니라 함수 선언자에 "*"를 붙여 함수의다른 실행 방식을 가능하게 하는 다소 이상한 방식으로 함수의 기능을 확장한다.

앞서의 생성자 함수(Generator Function) 예는 우리가 익히 아는 재귀 순환형 함수로 다음과 같이 구현할 수도 있다.

```javascript
function calcSum(start = 1, end = Infinit){
  let sum = 0;
  let current = start;
  return function calc(){
    if(current <= end){
      sum += current;
      current++;
    }
    return sum;
  }
}
let calcFunc = calcSum(1, 10);
let sum = 0, surrSum = 0;
do{
  sum = currSum;
  currSum = calcFunc();
}while(sum < currSum);
console.log(sum);
```


이 함수는 자바스크립트의 실행 상태를 기억하는 클로저(Closure)를 활용해 누적 합을 구하는 재귀형 함수호출을 사용한 것이다.

함수의 실행 구조가 명확하게 구분되고, 함수를 한번 호출하면 현재 기억된 상태값을 기준으로 한번 실행한다는 것을 명확하게 이해할 수 있다.

클로저를 사용하면 기존 자바스크립트 문법에 익숙하면서도 보다 가독성이 높은 코드를 생성할 수 있다.
do ~ while() 루프의 비교 방식이 불편하다면
for (let i = 1; i <= 10; i++){
  sum = calcFunc();
}
console.log(sum);
처럼 이미 알고 있는 시작과 끝 정수 값을 기초로 for() 순환문을 돌아 결과를 얻을 수도 있다.

잘 사용되진 않지만, 이 구현 방식을 사용하는 공개된 코드들이 있기 때문에 이런 코드를 접햇을대 어떤 방법으로 구현된 건지 이해할 필요가 있다.
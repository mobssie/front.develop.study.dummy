## 컴포지션 API

### 1. 프로젝트 규모에 따라 커지는 코드의 복잡성
컴포지션 API는 모든 코드를 독립적으로 정의할 수 있다. 각 기능을 함수로 묶어 처리하기 때문에 특정 기능의 유지보수를 위해 해당 함수만 확인하면 된다.
컴포넌트의 크기가 커질 경우 하나의 기능에 대한 코드가 여러 부분에서 작성되어 파편화되면서 유지보수가 어려워진다. 
따라서 컴포지션 API를 통해 기능을 모듈화하여 구성하는 것이 더 낫다.

### 2. 코드의 재사용이 어려움
믹스인(Mixins)이나 슬롯(Slots)등으로 컴포넌트 코드를 재사용할 수 있었다. 컴포넌트 로직을 재사용하기 위해 주로 이용되었던 믹스인은 한계점이 존재했다.
프로젝트가 커지고 믹스인을 사용해 다중으로 상속하게 되면 컴퓨넌트 관리가 어려워졌다. 예를들어, 각 기능의 속성이 병합될 때 이름이 충돌이 발생하기 쉬워 개발자 측면에서 네이밍에 대한 명확한 컨벤션이 필요했다. 또한 매개변수를 믹스인을 통해 전달할 수 없어 코드 재사용 시 유연성이 떨어졌다. 
여기서 컴포지션 API를 사용하면 인스턴스의 특정 기능 단위로 모듈화된 로직을 여러 컴포넌트에서 재사용할 수 있게 된다.
이는 대규모 프로젝트에서 로직의 유연성을 높여준다.


### 3. 제한된 타입스크립트 지원
vue.js 3.0은 타입스크립트를 더 적극적으로 지원하기 위해 코드베이스를 타입스크립트로 작성되었다. 이를 통해 개발자는 vue CLI로 타입스크립트 또는 자바스크립트를 사용하여 추가 도구 없이 Vue 앱을 생성할 수 있다. 물론 이전 버전의 Vue도 타입스크립트를 지원했다. 데코레이터를 이용하여 클래스 기반의 API를 선언하거나 Vue.extend로 컴포넌트를 정의해 기존 객체 구조 방식대로 사용할 수 있다. 
다만 vue.js가 기존에 옵션 API를 중심으로 객체 구조 방식을 사용하고 있기 때문에 타입스크립트를 온전히 사용하기에는 한계가 있었다. 타입스크립트의 타입 추론 방식은 명시적으로 선언하지 않아도 추론이 가능해야 하는데 객체 구조 특성상 개발자가 일일이 타입을 정의해 줘야 하는 상황이 많았기 때문이다.
Vue.js 3.0은 컴포지션 API와 함께 타입스크립트를 사용하기 위해서 컴포지션 API 내부의 setup()함수에서 자동으로 타입을 추론하기 때문에 사용하기가 훨씬 수월해졌다.



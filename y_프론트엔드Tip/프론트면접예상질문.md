# 프론트면접예상질문      

## javascript
> ### 호이스팅 :  
**- 호이스팅은 코드가 실행하기 전 변수선언/함수선언 이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상**  
**- let, const, class를 이용한 선언문을 호이스팅이 발생하지 않는 것처럼 동작**   
_자바스크립트 엔진은 코드를 실행하기 전 실행 컨텍스트를 위한과정에서 모든 선언(var, let, const, function, class)을 스코프에 등록한다.  

<br/><br/>

> ### 클로저 :
**- 내부함수가 외부함수의 맥락에 접근할 수 있는 것**  
_프라이빗한 변수를 만들때 사용한다 getter, setter같은것  

<br/><br/>

> ### Javascript 원시타입 :
**- string, number, bigint, boolean, undefined, ES6 부터 추가된 symbol**  
_원시타입(Primitive type)의 변수들은 데이터 복사가 일어날 때 메모리 공간을 새로 확보하여 독립적인 값을 저장하며 참조 타입은 메모리에 직접 접근이 아닌 메모리의 위치(주소)에 대한 간접적인 참조를 통해 메모리에 접근하는 데이터 타입  

<br/><br/>

> ### null, undefined 차이 :
**- null은 직접적으로 값이 없어라고 말한 상태이지만 undefined는 아무것도 하지 않은 상태**  

<br/><br/>

> ### call, apply, bind 차이
**- call, apply함수를 실행하고 함수의 첫 번째 인자로 전달하는 값에 this를 바인딩한다.**  
**- call과 apply함수의 차이는 apply는 인자를 배열의 형태로 전달하는 것**  
**- bind 함수는 함수가 가리키는 this만 바꾸고 호출하지는 않고 새로운 함수를 반환하는 것**  
_call, apply, bind에서 첫 번째 인자로 다른 것을 넣어주는 게 this를 바꾸는 방법 중 하나  
_호출하는 방법으로는 함수 뒤에 ()를 붙이는 것과, call 그리고 apply하는 방법이 있다.  

<br/><br/>

> ### `prototype과 __PROTO__`
**- 자바스크립트에서의 함수는 객체이고 객체는 property를 가진다.** 
**- 함수를 생성하면 prototype 객체도 같이 생성된다.**  
**- 새로운 객체를 생성할때 객체의 프로퍼티와 함께 __proto__ 프로퍼티가 같이 생성**  
**- __proto__는 부모 함수의 prototype을 바라봅니다. 그런 이유로 prototype link라고도 부릅니다.**  
**- 프로토타입 체인의 단방향을 지키기 위해서 __proto__ 프로퍼티로만 접근할 수 있다.**  
_프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해준다.

<br/><br/>

> ### this 란?
**- this는 일반적으로 메소드를 호출한 객체가 저장되어 있는 속성**  
**- 함수 호출 방식에 따라서 동적으로 결정**  


<br/><br/>

> ### 객체기준 this, 생성자기준 this
**- this는 글로벌 객체를, 메서드로 호출할 경우 이를 호출한 객체를, 생성자 함수를 호출할 경우, 생성자 함수가 생성할 인스턴스를 가리키게 된다.**  

<br/><br/>

> ### 배열, 유사배열의 차이점
**- 유사 객체 배열은 배열처럼 보이지만 사실 key가 숫자이고 length 값을 가지고 있는 객체를 말한다.**  
**- 배열같이 생겼지만 사실 객체**  

<br/><br/>

> ### 유사배열을 만드는 방법
**- querySelectorAll이나 document.body.children으로 엘리먼트를 가져오면 유사 배열 객체에 담긴다**
```js
const texts = document.querySelectorAll('.text');
console.log(texts);
```

<br/><br/>

> ### 유사배열을 배열로 만드는 방법
**- `Array.from()`으로 유사 배열 객체이 있는 value를 복사해 배열로 만드는 것**
```js
const texts = document.querySelectorAll('.text');
Array.from(texts).map((text) => console.log(text));
```

<br/><br/>

> ### Array.prototype.slice.call()의 동작원리
**- call은 상위 context를 변경하는 메소드이고, 이 코드가 존재하는 함수의 매개변수로 넘어온 값들을 array로 변환하겠다는 뜻**  
_ `function func(a,b)`에서 a와 b를 `arguments[0]과 arguments[1]`로 접근가능하다. *하지만,* arguments는 array가 아니며 object임.  
_ array로 변환할 필요가 있을 경우 `Array.prototype.slice.call(arguments)`를 사용하는 것  
_ 보통 아래와 같이 apply와 함께 사용
```js
let args = Arrays.prototype.slice.call(arguments);
func.apply(this, args);
```
_ apply는 call과 같이 상위 context를 변경해준다  
결과: `[arguments].slice();`  
_ 전달된 인자 중에 일부만 추출하기 위해 slice를 사용할 수 있다.

<br/><br/>

> ### es5, es6 변화된점 특징
**- let, const 사용으로 호이스팅 문제점 해결**
**- 화살표 사용으로 간결화**
**- default parameter로 초기값설정 간결**
**- Spread Opertor**

<br/><br/>

> ### var, let, const
**- var 중복선언가능**  
**- let 변수 중복 선언이 불가하지만, 재할당은 가능**  
**- const가 let과 다른 점이 있다면, 반드시 선언과 초기화를 동시에 진행되어야 한다.**  
_ let, const 키워드로 선언한 변수는 모두 코드 블록(ex. 함수, if, for, while, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.  
_ 변수의 스코프는 최대한 좁게 만드는 것을 권장

<br/><br/>

> ### for, for in, for of, foreach 차이
**- <span style="color:yellowgreen">for : </span> 초깃값부터 시작해서 증가 또는 감소하면서 조건에 부합하면 계속 순회**  

**- <span style="color:yellowgreen">for ... in 반복문 : </span> Object의 enumerable한 non-Symbol key(속성)들을 반복하는데 사용**  
* <span style="color:blue">key 값만 가져올 수 있음</span> : for in은 열거 가능한 값이 true로 설정되어 있어 key만 반복할 수 있고, Nonenumerable(비열거형)인 value에는 접근할 수 없다.  
* prototype chain으로부터 상속받은 속성들에 대해서도 반복  
* 키-값 쌍이 선호되는 데이터의 경우나 특정 값을 가진 키가 있는지 확인하려는 경우에는 for in이 유용  <br/><br/>

**- <span style="color:yellowgreen">for ... of 반복문 : </span> iterable한 Object(Array, Map, Set, String, TypedArray, arguments 등을 포함)에 대해 <span style="color:blue">속성값(value)</span>을 반복 순회**  
* 객체는 iterable하지 않기 때문에 for of를 사용하게 되면 타입에러가 뜬다.  
* forEach() 구문과 달리 break, continue, return 구문과 함께 사용할 수 있다.  <br/><br/>

**- <span style="color:yellowgreen">forEach() 메서드 :</span> 주어진 함수를 <span style="color:blue">배열 요소들에 대해 반복 작업을 실행</span>**  
* forEach() 인자로 **callback 함수가 오고 배열의 각 요소들이 반복될 때 이 callback 함수가 호출**된다. callback 함수에서 배열 요소의 인덱스와 값에 접근할 수 있다.  
* forEach()는 map()이나 reduce()와 달리 undefined를 반환하기 때문에 break, continue, return 구문을 사용해서 함수를 벗어날 수 없다.

<br/><br/>

> ### Event 델리게이션




<br/><br/>


> ### 이벤트 버블링, 캡쳐링

<br/><br/>


> ### deep copy, shallow copy

<br/><br/>

> ### webpack- css loader, babel loader 란?

<br/><br/>

> ### chunk

<br/><br/>

> ### xhr (이벤트), fetch 차이

<br/><br/>

> ### Try catch, then catch

<br/><br/>



+ 브라우저
> ### SSR, CSR
> ### CORS 이슈 원인
> ### http https 차이점
> ### 브라우저 렌더링 과정에 대해 설명. reflow, repaint 이란
> ### 브라우저 저장소에대해 설명해주세요
> ### Script 태그를 head에 넣었을때 body에 넣었을때의 차이점
> ### 이벤트 루프



+ React 경험
> ### virtual dom
> ### lazy-loading
> ### 라이프사이클
> ### Redux 상태관리 사이클
> ### 사용해본 미들웨어, 사용이유
> ### React 16.8버전에 추가된 Hook 에대한 설명


+ Vue
> ### 라이프사이클
> ### 양방향 바인딩
> ### 클래스 컴포넌트
> ### nextTick
> ### Vue mixin
> ### Vue slot
> ### v-for : key
> ### 변이 메소드: push, pop, shift, unshift, splice, sort, reverse



+ git
> ### git 브랜치 전략
> ### merge/rebase 차이점
> ### Fetch/pull 차이점
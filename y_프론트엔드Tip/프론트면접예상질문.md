# 프론트면접예상질문      

## javascript
> #### 호이스팅 :  
**- 호이스팅은 코드가 실행하기 전 변수선언/함수선언 이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상**  
**- let, const, class를 이용한 선언문을 호이스팅이 발생하지 않는 것처럼 동작**   
_자바스크립트 엔진은 코드를 실행하기 전 실행 컨텍스트를 위한과정에서 모든 선언(var, let, const, function, class)을 스코프에 등록한다.  

---

> #### 클로저 :
**- 내부함수가 외부함수의 맥락에 접근할 수 있는 것**  
_프라이빗한 변수를 만들때 사용한다 getter, setter같은것  

---

> #### Javascript 원시타입 :
**- string, number, bigint, boolean, undefined, ES6 부터 추가된 symbol**  
_원시타입(Primitive type)의 변수들은 데이터 복사가 일어날 때 메모리 공간을 새로 확보하여 독립적인 값을 저장하며 참조 타입은 메모리에 직접 접근이 아닌 메모리의 위치(주소)에 대한 간접적인 참조를 통해 메모리에 접근하는 데이터 타입  

----

> #### null, undefined 차이 :
**- null은 직접적으로 값이 없어라고 말한 상태이지만 undefined는 아무것도 하지 않은 상태**  

---

> #### call, apply, bind 차이
**- call, apply함수를 실행하고 함수의 첫 번째 인자로 전달하는 값에 this를 바인딩한다.**  
**- call과 apply함수의 차이는 apply는 인자를 배열의 형태로 전달하는 것**  
**- bind 함수는 함수가 가리키는 this만 바꾸고 호출하지는 않고 새로운 함수를 반환하는 것**  
_call, apply, bind에서 첫 번째 인자로 다른 것을 넣어주는 게 this를 바꾸는 방법 중 하나  
_호출하는 방법으로는 함수 뒤에 ()를 붙이는 것과, call 그리고 apply하는 방법이 있다.  

---

> #### `prototype과 __PROTO__`
**- 자바스크립트에서의 함수는 객체이고 객체는 property를 가진다.** 
**- 함수를 생성하면 prototype 객체도 같이 생성된다.**  
**- 새로운 객체를 생성할때 객체의 프로퍼티와 함께 __proto__ 프로퍼티가 같이 생성**  
**- __proto__는 부모 함수의 prototype을 바라봅니다. 그런 이유로 prototype link라고도 부릅니다.**  
**- 프로토타입 체인의 단방향을 지키기 위해서 __proto__ 프로퍼티로만 접근할 수 있다.**  
_프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해준다.

---

> #### this 란?
**- this는 일반적으로 메소드를 호출한 객체가 저장되어 있는 속성**  
**- 함수 호출 방식에 따라서 동적으로 결정**  


---

> #### 객체기준 this, 생성자기준 this
**- this는 글로벌 객체를, 메서드로 호출할 경우 이를 호출한 객체를, 생성자 함수를 호출할 경우, 생성자 함수가 생성할 인스턴스를 가리키게 된다.**  

---

> #### 배열, 유사배열의 차이점
**- 유사 객체 배열은 배열처럼 보이지만 사실 key가 숫자이고 length 값을 가지고 있는 객체를 말한다.**  
**- 배열같이 생겼지만 사실 객체**  

---

> #### 유사배열을 만드는 방법
**- querySelectorAll이나 document.body.children으로 엘리먼트를 가져오면 유사 배열 객체에 담긴다**
```js
const texts = document.querySelectorAll('.text');
console.log(texts);
```

---

> #### 유사배열을 배열로 만드는 방법
**- `Array.from()`으로 유사 배열 객체이 있는 value를 복사해 배열로 만드는 것**
```js
const texts = document.querySelectorAll('.text');
Array.from(texts).map((text) => console.log(text));
```

---



> #### Array.prototype.slice.call의 동작원리
> #### es5, es6 변화된점 특징
> #### var, let, const
> #### for, for in, for of, foreach 차이
> #### Event 딜리게이션
> #### 이벤트 버블링, 캡쳐링
> #### deep copy, shallow copy
> #### webpack- css loader, babel loader 란?
> #### chunk
> #### xhr (이벤트), fetch 차이
> #### Try catch, then catch



+ 브라우저
> #### SSR, CSR
> #### CORS 이슈 원인
> #### http https 차이점
> #### 브라우저 렌더링 과정에 대해 설명. reflow, repaint 이란
> #### 브라우저 저장소에대해 설명해주세요
> #### Script 태그를 head에 넣었을때 body에 넣었을때의 차이점
> #### 이벤트 루프



+ React 경험
> #### virtual dom
> #### lazy-loading
> #### 라이프사이클
> #### Redux 상태관리 사이클
> #### 사용해본 미들웨어, 사용이유
> #### React 16.8버전에 추가된 Hook 에대한 설명


+ Vue
> #### 라이프사이클
> #### 양방향 바인딩
> #### 클래스 컴포넌트
> #### nextTick
> #### Vue mixin
> #### Vue slot
> #### v-for : key
> #### 변이 메소드: push, pop, shift, unshift, splice, sort, reverse



+ git
> #### git 브랜치 전략
> #### merge/rebase 차이점
> #### Fetch/pull 차이점
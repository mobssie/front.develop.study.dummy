## this가 이런거군
this가 알고 있었던 것과 달리 호출부(함수가 어떻게 호출됐는가?)에서 함수를 호출할 때 바인딩 된다
### 2.1 호출부
this 바인딩의 개념을 이해하려면 먼저 호출부, 즉 함수 호출(선언이 아니다) 코드부터 확인하고 'this가 가리키는 것'이 무엇인지 찾아봐야한다.

호출부는 '함수를 호출한 지점'으로 돌아가면 금세 확인할 수 있을 것 같지만 코딩 패턴에 따라 '진짜' *호출부가 어디인지 모호할 때*가 많아 생각만큼 그리 쉽지 않다. 
중요한 건 호출 스택(햔재 실행 지점에 오기까지 호출된 함수의 스택)을 생각해보는 것이다. 이 중 호출부는 현재 실행 중인 함수 '직전'의 호출 코드 '내부'에 있다.

#### 호출부와 호출 스택을 설명하기 위한 예

```javascript
function baz() {
  // 호출 스택: 'baz'
  // 따라서 호출부는 전역 스코프 내부다.
  console.log('baz');
  bar(); // 'bar'의 호출부
}
function bar() {
  // 호출 스택: 'baz' -> 'bar'
  // 따라서 호출부는 'baz' 내부다.
  console.log('bar');
  foo(); // 'foo' 호출부
}
function foo() {
  // 호출 스택: 'baz' -> 'bar' -> 'foo'
  // 따라서 호출부는 'bar'내부다.
  console.log('foo')
}
baz(); // baz의 호출부
```

dev.tip/크롬 개발자 도구에서 디버깅.md
에서 확인할것.

### 2.2 단지 규칙일뿐
this가 무엇을 참조할지를 호출바가 어떻게 결정할까

4가지 규칙중 어느 것이 해당하는지 확인 한다.
2.2.1 기본 바인딩
2.2.2 암시적 바인딩
2.2.3 명시적 바인딩
#### 2.2.1 기본 바인딩
첫번째 규칙은 가장 평범한 함수 호출이 '단독 함수 실행(Standalone Function Invocation)'에 관한 규칙으로 나머지 규칙에 해당하지 않을 경우 적용되는 this의 기본(Default)규칙이다.
```javascript
function foo() {
  console.log( this.a );
}
var a = 2;
foo(); // 2
```
var a = 2처럼 전역 스코프에 변수를 선언하면 변수명과 같은 이름의 전역 객체 프로퍼티가 생성된다. 이는 서로 사본이 아니고 같은 동전의 앞뒤면이라고 보면 된다.
그리고 foo() 함수 호출 시 this.a는 전역 객체 a다. 기본 바인딩이 적용되어 this는 전역 객체를 참조한다.

기본 바인딩 규칙이 적용됐다는 건 어찌 알 수 있을까?
foo() 함수의 호출부를 보자, foo()는 지극히 평범한 있는 그대로의 함수 레퍼런스로 호출했다. 나머지 규칙을 노할 여지도 없이 기본 바인딩이 그대로 적용됐다.

엄격 모드(Strict Mode)에서는 전역 객체가 기본 바인딩 대상에서 제외된다. 그래서 this는 undefined가 된다.
```javascript
function foo() {
  "use strict";
  console.log( this.a );
}
var a = 2;
foo() // TypeError: 'this' is 'undefined'
```
미묘하지만 중요한 사실은 보통 this 바인딩 규칙은 오로지 호출부에 의해 좌우되지만 비엄격모드(Non-strict Mode)에서 foo()함수의 본문을 실행하면 전역 객체만이 기본 바인딩의 유일한 대상이라는 점. foo() 호출부의 엄격 모드 여부는 상관 없다.

```javascript
function foo() {
  console.log( this.a );
}
var a = 2;
(function(){
  "use strict";
  foo(); // 2
})
```
>> 그렇다고 엄격 모드와 비엄격 모드를 마구 섞어 쓰면 탈이 난다. 프로그램 전체에서 두 모드 중 하나만 쓰자. 
단, 외부 서드 파티 라이브러리를 가져다 사용할 때 여러분 코드의 모드와 다르다면 호환성 이슈를 살펴야 한다.

#### 2.2.2 암시적 바인딩
두 번째 규칙은 호출부에 콘텍스트 객체가 있는지, 즉 객체의 소유(Owning)/포함(Containing)여부를 확인하는 것.
```javascript
function foo() {
  console.log( this.a );
}
var obj = {
  a: 2,
  foo: foo
}
obj.foo(); // 2
```
앞에서 선언한 foo() 함수를 obj에서 프로퍼티로 참조하고 있다. foo()를 처음부터 foo 프로퍼티로 선언하든 이 예제처럼 나중에 레퍼런스로 추가하든 obj 객체가 이 함수를 정말로 '소유'하거나 '포함'한 것은 아니다. 그러나 호출부는 obj 콘텍스트로 foo()를 참조하므로 obj 객체는 함수 호출 시점에 함수의 레퍼런스 '소유'하거나 '포함'한다고 볼 수 있다.

이런 패턴을 뭐라 하건 foo() 호출 시점에 이미 obj 객체 레퍼런스는 준비된 상태이다. 함수 레퍼런스에 대한 콘텍스트 객체가 존재할 때 암시적 바인딩(Implicit Binding) 규칙에 따르면 바로 이 콘텍스트 객체가 함수 호출 시 this 바인딩이 된다.